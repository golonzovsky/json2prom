package main

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"os"
	"time"

	"github.com/itchyny/gojq"
	"github.com/prometheus/client_golang/prometheus"
)

type Poller struct {
	tgt     Target
	client  *http.Client
	metrics []*metricBinding
	period  time.Duration
	logger  *slog.Logger
}

type metricBinding struct {
	cfg          MetricConfig
	itemsQuery   *gojq.Query
	valueQuery   *gojq.Query
	labelQueries map[string]*gojq.Query
	gaugeVec     *prometheus.GaugeVec
}

func NewPoller(tgt Target, logger *slog.Logger) (*Poller, error) {
	if tgt.PeriodSeconds <= 0 {
		return nil, errors.New("periodSeconds must be > 0")
	}

	if tgt.UseBearerTokenFrom != "" && os.Getenv(tgt.UseBearerTokenFrom) == "" {
		return nil, errors.New("requested bearer token env var is not set: " + tgt.UseBearerTokenFrom)
	}

	p := &Poller{
		tgt: tgt,
		client: &http.Client{
			Timeout: 10 * time.Second,
		},
		period: time.Duration(tgt.PeriodSeconds) * time.Second,
		logger: logger.With("target", tgt.Name),
	}

	for _, m := range tgt.Metrics {
		mb, err := prepareMetric(m)
		if err != nil {
			return nil, fmt.Errorf("metric %s: %w", m.Name, err)
		}
		p.metrics = append(p.metrics, mb)
	}

	return p, nil
}

func prepareMetric(mc MetricConfig) (*metricBinding, error) {
	labelNames := make([]string, 0, len(mc.Labels))
	labelQueries := make(map[string]*gojq.Query)
	for _, l := range mc.Labels {
		labelNames = append(labelNames, l.Name)
		q, err := gojq.Parse(l.Query)
		if err != nil {
			return nil, fmt.Errorf("label %s query parse: %w", l.Name, err)
		}
		labelQueries[l.Name] = q
	}

	itemsQuery := "."
	if mc.ItemsQuery != "" {
		itemsQuery = mc.ItemsQuery
	}
	itemsQ, err := gojq.Parse(itemsQuery)
	if err != nil {
		return nil, fmt.Errorf("itemsQuery parse: %w", err)
	}
	valueQ, err := gojq.Parse(mc.ValueQuery)
	if err != nil {
		return nil, fmt.Errorf("valueQuery parse: %w", err)
	}

	g := prometheus.NewGaugeVec(prometheus.GaugeOpts{
		Name: mc.Name,
		Help: mc.Name + " generated by json2prom",
	}, labelNames)
	prometheus.MustRegister(g)

	return &metricBinding{
		cfg:          mc,
		itemsQuery:   itemsQ,
		valueQuery:   valueQ,
		labelQueries: labelQueries,
		gaugeVec:     g,
	}, nil
}

func (p *Poller) Run(ctx context.Context) {
	ticker := time.NewTicker(p.period)
	defer ticker.Stop()

	p.scrapeOnce(ctx)

	for {
		select {
		case <-ticker.C:
			p.scrapeOnce(ctx)
		case <-ctx.Done():
			return
		}
	}
}

func (p *Poller) scrapeOnce(ctx context.Context) {
	p.logger.Debug("polling target", "url", p.tgt.URI)
	req, err := p.buildRequest(ctx)
	if err != nil {
		p.logger.Error("build request failed", "error", err)
		return
	}
	resp, err := p.client.Do(req)
	if err != nil {
		p.logger.Error("http error", "error", err)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode/100 != 2 {
		p.logger.Warn("non-2xx status", "status", resp.StatusCode)
		return
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		p.logger.Error("read body", "error", err)
		return
	}

	var jsonObj any
	if err := json.Unmarshal(body, &jsonObj); err != nil {
		p.logger.Error("json decode", "error", err)
		return
	}

	p.evaluate(jsonObj)
}

func (p *Poller) buildRequest(ctx context.Context) (*http.Request, error) {
	method := p.tgt.Method
	if method == "" {
		method = http.MethodGet
	}

	var body io.Reader
	if len(p.tgt.FormParams) > 0 {
		vals := url.Values{}
		for k, v := range p.tgt.FormParams {
			vals.Set(k, v)
		}
		body = bytes.NewBufferString(vals.Encode())
	}

	req, err := http.NewRequestWithContext(ctx, method, p.tgt.URI, body)
	if err != nil {
		return nil, err
	}
	for k, v := range p.tgt.Headers {
		req.Header.Set(k, v)
	}
	if p.tgt.UseBearerTokenFrom != "" {
		req.Header.Set("Authorization", "Bearer "+os.Getenv(p.tgt.UseBearerTokenFrom))
	}
	return req, nil
}

func (p *Poller) evaluate(jsonObj any) {
	for _, mb := range p.metrics {
		mb.gaugeVec.Reset()

		iter := mb.itemsQuery.Run(jsonObj)
		for {
			v, ok := iter.Next()
			if !ok {
				break
			}
			if err, ok := v.(error); ok {
				p.logger.Error("itemsQuery error", "error", err)
				continue
			}

			item := v
			valRaw, _ := mb.valueQuery.Run(item).Next()
			num, err := toFloat64(valRaw)
			if err != nil {
				p.logger.Error("valueQuery", "error", err)
				continue
			}

			labelVals := make([]string, 0, len(mb.cfg.Labels))
			for _, l := range mb.cfg.Labels {
				lv, _ := mb.labelQueries[l.Name].Run(item).Next()
				if s, ok := lv.(string); ok {
					labelVals = append(labelVals, s)
				} else {
					labelVals = append(labelVals, fmt.Sprint(lv))
				}
			}
			mb.gaugeVec.WithLabelValues(labelVals...).Set(num)
		}
	}
}

func toFloat64(v any) (float64, error) {
	switch t := v.(type) {
	case float64:
		return t, nil
	case int:
		return float64(t), nil
	case int64:
		return float64(t), nil
	case bool:
		if t {
			return 1, nil
		}
		return 0, nil
	default:
		return 0, fmt.Errorf("cannot convert %T to float64", v)
	}
}
